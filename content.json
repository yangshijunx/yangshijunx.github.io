{"meta":{"title":"1Bit","subtitle":"","description":"不积硅步无以至千里，不积小流无以成江海","author":"1Bit","url":"https://yangshijunx.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-09-19T12:19:09.000Z","updated":"2023-09-19T14:26:48.208Z","comments":true,"path":"categories/index.html","permalink":"https://yangshijunx.github.io/categories/index.html","excerpt":"","text":""},{"title":"repository","date":"2023-09-19T12:21:51.000Z","updated":"2023-09-19T12:21:51.558Z","comments":true,"path":"repository/index.html","permalink":"https://yangshijunx.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-09-19T12:19:56.000Z","updated":"2023-09-19T14:27:04.378Z","comments":true,"path":"tags/index.html","permalink":"https://yangshijunx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react文档review","slug":"react文档review","date":"2023-11-08T23:03:15.000Z","updated":"2023-11-08T15:05:08.420Z","comments":true,"path":"2023/11/08/react文档review/","link":"","permalink":"https://yangshijunx.github.io/2023/11/08/react%E6%96%87%E6%A1%A3review/","excerpt":"","text":"react文档阅读Created: November 6, 2023 10:19 PMClass: 前端Type: ReactMaterials: https://react.dev/learnReviewed: No 使用jsx 一个组件返回一个根元素，可以使用div包裹或者空标签包裹 1234567891011&lt;&gt; &lt;h1&gt;Hedy Lamarr&#x27;s Todos&lt;/h1&gt; &lt;img src=&quot;https://i.imgur.com/yXOvdOSs.jpg&quot; alt=&quot;Hedy Lamarr&quot; class=&quot;photo&quot; &gt; &lt;ul&gt; ... &lt;/ul&gt;&lt;/&gt; 为什么不能返回两个呢？ JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment. jsx中的标签都必须闭合 &lt;img&gt; 必须是&lt;img /&gt; 在jsx中大部分时候使用驼峰命名法，在做迁移的时候可以使用转黄工具诸如：https://transform.tools/html-to-jsx 例如class写成className， 但是也有例外 For historical reasons, [aria-*](https://developer.mozilla.org/docs/Web/Accessibility/ARIA) and [data-*](https://developer.mozilla.org/docs/Learn/HTML/Howto/Use_data_attributes) attributes are written as in HTML with dashes. 在jsx中使用 &#123;&#125; 访问js中的内容，官网描述In this situation, you can use curly braces in your JSX to open a window to JavaScript. 通过引号将字符串数据传递给标签或者组件属性， 123456789export default function Avatar() &#123; return ( &lt;img className=&quot;avatar&quot; src=&quot;https://i.imgur.com/7vQD0fPs.jpg&quot; alt=&quot;Gregorio Y. Zara&quot; /&gt; );&#125; 如果是使用js的变量动态赋值只需要使用&#123;&#125; 替换 “” 1234567891011export default function Avatar() &#123; const avatar = &#x27;https://i.imgur.com/7vQD0fPs.jpg&#x27;; const description = &#x27;Gregorio Y. Zara&#x27;; return ( &lt;img className=&quot;avatar&quot; src=&#123;avatar&#125; alt=&#123;description&#125; /&gt; );&#125; &#123;&#125; : A window into the JavaScript world ps:Using “double curlies”: CSS and other objects in JSX 如果赋值对象，直接写的话需要使用双括号。 12345678person=&#123;&#123; name: &quot;Hedy Lamarr&quot;, inventions: 5 &#125;&#125;&lt;ul style=&#123; &#123; backgroundColor: &#x27;black&#x27;, color: &#x27;pink&#x27; &#125;&#125;&gt;// 内联css属性需要使用驼峰命名法 组件传参props step1传参 12345678export default function Profile() &#123; return ( &lt;Avatar person=&#123;&#123; name: &#x27;Lin Lanying&#x27;, imageId: &#x27;1bX5QH6&#x27; &#125;&#125; size=&#123;100&#125; /&gt; );&#125; step2解构props 123function Avatar(&#123; person, size &#125;) &#123; // person and size are available here&#125; ps：in fact, props are the only argument to your component! React component functions accept a single argument, a props object: 组件只能接收一个参数就是props。 给props设置默认值 123function Avatar(&#123; person, size = 100 &#125;) &#123; // ...&#125; 默认值何时生效？ The default value is only used if the size prop is missing or if you pass size=&#123;undefined&#125;. But if you pass size=&#123;null&#125; or size=&#123;0&#125;, the default value will not be used. 也就是说只有不传值，或者传值为undefined时生效，null和0并不会使用默认值。 props传值简化 如果我们在传值的时候属性名和变量名相同，那么我们可以这样简化代码 12345678910111213141516171819202122function Profile(&#123; person, size, isSepia, thickBorder &#125;) &#123; return ( &lt;div className=&quot;card&quot;&gt; &lt;Avatar person=&#123;person&#125; size=&#123;size&#125; isSepia=&#123;isSepia&#125; thickBorder=&#123;thickBorder&#125; /&gt; &lt;/div&gt; );&#125;简化如下======&gt;function Profile(props) &#123; return ( &lt;div className=&quot;card&quot;&gt; &lt;Avatar &#123;...props&#125; /&gt; &lt;/div&gt; );&#125; 插槽 When you nest content inside a JSX tag, the parent component will receive that content in a prop called children. For example, the Card component below will receive a children prop set to &lt;Avatar /&gt; and render it in a wrapper div: You can think of a component with a children prop as having a “hole” that can be “filled in” by its parent components with arbitrary JSX. 1234567891011121314151617181920212223import Avatar from &#x27;./Avatar.js&#x27;;function Card(&#123; children &#125;) &#123; return ( &lt;div className=&quot;card&quot;&gt; &#123;children&#125; &lt;/div&gt; );&#125;export default function Profile() &#123; return ( &lt;Card&gt; &lt;Avatar size=&#123;100&#125; person=&#123;&#123; name: &#x27;Katsuko Saruhashi&#x27;, imageId: &#x27;YfeOqp2&#x27; &#125;&#125; /&gt; &lt;/Card&gt; );&#125; props的值并不是静态的，而是动态变化的，需要注意的是react内部数据是单向流动的也就说我们不能在子组件内部修改props的值而是应该在父组件中修改流向子组件。 However, props are immutable—a term from computer science meaning “unchangeable”. When a component needs to change its props (for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass it *different props*—a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them. Don’t try to “change props”. When you need to respond to the user input (like changing the selected color), you will need to “set state”, which you can learn about in State: A Component’s Memory. 条件渲染主要语法：In React, you can conditionally render JSX using JavaScript syntax like if statements, &amp;&amp;, and ? : operators. 12345678910111213141516171819202122232425262728function Item(&#123; name, isPacked &#125;) &#123; if (isPacked) &#123; return &lt;li className=&quot;item&quot;&gt;&#123;name&#125; ✔&lt;/li&gt;; &#125; return &lt;li className=&quot;item&quot;&gt;&#123;name&#125;&lt;/li&gt;;&#125;export default function PackingList() &#123; return ( &lt;section&gt; &lt;h1&gt;Sally Ride&#x27;s Packing List&lt;/h1&gt; &lt;ul&gt; &lt;Item isPacked=&#123;true&#125; name=&quot;Space suit&quot; /&gt; &lt;Item isPacked=&#123;true&#125; name=&quot;Helmet with a golden leaf&quot; /&gt; &lt;Item isPacked=&#123;false&#125; name=&quot;Photo of Tam&quot; /&gt; &lt;/ul&gt; &lt;/section&gt; );&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yangshijunx.github.io/tags/React/"}]},{"title":"Sass进阶","slug":"Sass进阶","date":"2023-11-06T23:55:14.000Z","updated":"2023-11-08T15:05:08.420Z","comments":true,"path":"2023/11/06/Sass进阶/","link":"","permalink":"https://yangshijunx.github.io/2023/11/06/Sass%E8%BF%9B%E9%98%B6/","excerpt":"","text":"sass进阶（包含css原子化内容）Created: November 6, 2023 10:18 PMClass: sassType: vueReviewed: No SASS在前端开发中sass是必不可少的技能，在开发中对sass最明显的体验就是css嵌套以及变量功能，但是Sass（Syntactically Awesome Stylesheets）作为一种CSS的扩展语言，其内部还有很多增强和有用的功能，以简化和改进CSS代码的编写和维护。Sass具有以下主要特点： 变量sass允许你定义变量来存储颜色，字体，边距等css属性的值，使得在整个样式表中一致地使用这些变量变得容易，可以轻松复用。 嵌套规则：可以嵌套CSS规则，以更清晰地表示HTML元素之间的层次关系。这有助于减少代码的嵌套深度，提高可读性（但是需要避免过深嵌套） 混合器：混合器允许你定义可重用的样式片段，并在多个地方引用它们。这有助于减少代码的重复，使样式更易维护。 继承：Sass支持样式继承，允许一个选择器继承另一个选择器的属性。这有助于创建DRY（Don’t Repeat Yourself）的样式表。 模块化：Sass允许将样式表拆分为多个文件，然后将它们导入到主样式表中，以帮助组织和管理大型项目的样式。 运算：Sass支持在样式中执行算术运算，包括加法、减法、乘法和除法。这使得可以动态计算属性的值。 sass文件已”.scss”或者“.sass”拓展名，生产环境西药编译成css文件，我们在使用webapack进行开发的时候，webpack承担了自动化编译的工作。总的来说，Sass是一种强大的CSS预处理器，它使CSS代码更加模块化、易维护和可读，同时提供了许多便捷的功能来提高前端开发的效率。 ps：这里需要注意一下sass和scss的区别 语法规则: Sass: Sass使用缩进风格的语法，不使用大括号 &#123;&#125; 和分号 **;**。选择器和属性之间使用缩进来表示层次关系。 Scss: Scss使用类似于标准CSS的语法，使用大括号 &#123;&#125; 包围规则块，以及分号 ; 来分隔属性。这使得Scss更接近标准CSS。 文件扩展名: Sass: Sass文件使用 .sass 扩展名。 Scss: Scss文件使用 .scss 扩展名。 易读性: Sass: 由于缩进风格的语法，Sass文件通常更加紧凑，但在视觉上可能不如Scss易读。 Scss: Scss更接近标准CSS，因此它通常更容易阅读和理解，特别是对那些熟悉CSS的开发者来说。 兼容性: Sass: 由于不使用大括号和分号，Sass的语法在某些情况下可能会导致一些语法错误，需要开发者小心处理。 Scss: Scss更接近标准CSS，因此在语法上更容易转换和适应。 sass基础使用sass安装1npm install sass 使用sass将sass类型文件转换为css 1234567.box &#123; .box-content &#123; color: red; &#125;&#125;// 正常来说浏览器是不能直接识别嵌套css的，chrome v112 已经支持嵌套了// 所以我们需要将scss变异成css sass提供四种编译选项 1234nested：嵌套缩进的css代码，它是默认值。expanded：没有缩进的、扩展的css代码。compact：简洁格式的css代码。compressed：压缩后的css代码。 生产环境一般使用compressed，编译命令 1npx sass --style compressed index.scss style.css 编译结果如下： sass使用变量123456$prim-color: green;.box &#123; .box-content &#123; color: $prim-color; &#125;&#125; 同样我们可以将变量嵌套在字符串中，需要写在#{}之中 12345678910$prim-color: green;$side: left;.box &#123; .box-content &#123; color: $prim-color; &#125; .box-side &#123; margin-#&#123;$side&#125;: 30px; &#125;&#125; 使用sass计算功能123456789101112$prim-color: green;$marginLeft: 50px;$side: left;.box &#123; .box-content &#123; color: $prim-color; &#125; .box-side &#123; margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; sass继承功能，代码复用1234567891011121314$prim-color: green;$marginLeft: 50px;$side: left;.box &#123; .box-content &#123; color: $prim-color; background-color: red; &#125; .box-side &#123; @extend .box-content; margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; Mixin（可以复用的代码块）1234567891011121314$prim-color: green;$marginLeft: 50px;$side: left;.box &#123; .box-content &#123; color: $prim-color; background-color: red; &#125; .box-side &#123; @extend .box-content; margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; mixin支持传参 123456789101112131415161718192021222324$prim-color: green;$marginLeft: 50px;$side: left;@mixin flex-row &#123; display: flex; flex-direction: row;&#125;@mixin right($right: 40px) &#123; margin-right: $right;&#125;.box &#123; .box-content &#123; @include right(); color: $prim-color; background-color: red; &#125; .box-side &#123; @extend .box-content; @include flex-row; @include right(30px); margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; sass内置颜色函数1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c darken($color, $amount) 将color颜色加深amount介于0-100%之间 lighten($color, $amount) 将颜色 $color 变亮$mount 是介于 0% 到 100% (含) 之间的值。按照这个值增加 $color HSL 的亮度。 mix($color1, $color2, $weight: 50%) 将颜色 $color1 与 $color2 混合在一起生成新的颜色，$weight 与透明度决定了每个颜色在结果里占的比重。$weight 默认值为 50%。取值范围是介于 0% 到 100% (含) 之间的值。如果指定的比例是 25% ,这意味着第一个颜色所占比例为 25%，第二个颜色所占比例为 75%。 插入文件12@import &quot;index.scss&quot;;@import &quot;index.css&quot;; 循环语句for循环 12345@for $i from 1 through 10 &#123; .margin-left-#&#123;$i&#125; &#123; margin-left: #&#123;$i&#125;px; &#125;&#125; while循环 1234567$index: 1;@while $index &lt; 10 &#123; .margin-right-#&#123;$index&#125; &#123; margin-right: #&#123;$index&#125;px; &#125; $index: $index + 1;&#125; each命令 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(&quot;/image/#&#123;$member&#125;.jpg&quot;); &#125; &#125; 自定义函数123456@function doubleValue($value) &#123; @return $value * 2;&#125;.box-side &#123; border: doubleValue(10px) solid black;&#125; 进阶内容sass变量作用域名 在这个例子中可以看出，Sass 中的变量没有块级作用域特性，而是随执行随覆盖随调用。调用的前面没有变量声明，就报错，有很多变量声明，就调用在它上面离它最近的变量值，使用时最好是在顶部声明，之后全局调用就可以了。 引用父级元素 &amp;可以用 &amp; 符号代替父级选择器，超级实用，例如： 1234567891011121314$width: 120px;.main &#123; .content &#123; width: $width; $width: 130px; &#125; $width: 140px; .sidebar &#123; width: $width; &amp;::after &#123; content: &quot;测试&quot;; &#125; &#125;&#125; sass中的四则运算Sass 支持 加法（＋）、减法（－）、乘法（＊）、除法（／）以及取余（％） 数值相加12345$width1: 100px;$width2: 200px;.main &#123; width: $width1 + $width2;&#125; 输出 1.main&#123;width:300px&#125;/*# sourceMappingURL=style.css.map */ 这里的变量具有字符单位，但是sass在进行计算的时候会进行计算并对单位进行处理。 字符串相加1234.main::after &#123; content: &quot;hello &quot; + world; font-family: sans- + &quot;serif&quot;;&#125; 输出 12.main::after&#123;content:&quot;hello world&quot;;font-family:sans-serif&#125;/*# sourceMappingURL=style.css.map */ 加法连接字符串时，对于引号的合并也有一定规则，如果前面字符串带有引号，后面字符串会自动包含在引号中，如果前面没有，后面带有引号的字符串也会去掉引号。 可以使用#{}进行加法数值运算 1234$num: 12;.main::before &#123; content: &quot;这是啥&quot; + #&#123;$num + 1&#125;;&#125; 输出 1.main::before&#123;content:&quot;这是啥13&quot;&#125;/*# sourceMappingURL=style.css.map */ @extend和**@mixin**@extend可以直接继承另一个选择器中的属性，如果只在 CSS 中去对每个结构实现 clearfix 的效果，要么把这段代码不停的复制到对应选择器中，产生大量冗余，要么就把这个结构选择器翻到上面去找 .clearfix 类，加在后面，费时费力。 @mixin 定义的是一个片段，这个片段可以是类似变量的一段文字一条属性，也可以是一整个选择器和内容，也可以是一个选择器的一部分 CSS 代码。此外还可以传递参数，通过参数生成不同代码。它需要配合 @inclde 命令来引用这段代码，类似复制的效果。@mixin 定义的内容，不会编译输出。 可以实现类似函数效果 12345678@mixin border-radius($radius: 5px) &#123; -webkit-border-radius: $radius; -moz-border-radius: $radius; border-radius: $radius;&#125;.content &#123; @include border-radius(10px);&#125; 输出 1.content&#123;-webkit-border-radius:10px;-moz-border-radius:10px;border-radius:10px&#125;/*# sourceMappingURL=style.css.map */","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://yangshijunx.github.io/tags/Sass/"}]},{"title":"","slug":"web端播放透明视频","date":"2023-11-06T14:25:25.591Z","updated":"2023-11-06T14:25:25.591Z","comments":true,"path":"2023/11/06/web端播放透明视频/","link":"","permalink":"https://yangshijunx.github.io/2023/11/06/web%E7%AB%AF%E6%92%AD%E6%94%BE%E9%80%8F%E6%98%8E%E8%A7%86%E9%A2%91/","excerpt":"","text":"web端播放透明视频前两天做了一个官网的项目，产品要求在网页上放一个视频用来介绍这个网站，但是呢要求只保留介绍的人物，不能有多余的环境内容，效果大致是这样的。 产品拿来的效果是一个视频文件，所以没有办法判断参考对象采用的是建模还是直接就在视频上做的效果，仔细想一下直接播放视频不就可以了，想实现这样的效果首先播放器要透明，然后就需要在浏览器中播放带有透明通道的视频就可以了，ok逻辑理清了，就可以开工了。 第一步，播放器透明好像不用哈哈哈哈，播放器就是透明的，不显示播放控件就可以了，那接下来主要的工作就是将介绍视频只保留人像就可以了，产品提供的是绿幕的人像视频使用pr的超级键处理之后，导出格式为mov的保留透明通道的视频就可以了。 第二步，将视频导出只包含人像 在效果里面找到超级键，然后拖拽到视频轨道上面。 点击视频轨道找到效果控件中的超级建选中绿幕，在这个过程中可以选择Alpha通道多次调整，宽容度等参数直到合适。 接着就可以导出视频了，Pr中可以选择QuickTime中具有透明通道的选项。 不出意外，导出的视频是mov格式的，并且相比于原视频会变大很多，我这里两分钟的视频导出的视频3个多G，放到web端这不是开玩笑(别急)。 刚开始，想的是能不能通过压缩视频的形式实现，多番尝试之后失败了，单纯压缩mov视频不能实现，那我可不可以采用别的方式？想了好久，我突然想到之前在做数据可视化项目的时候UI使用AE导出过一个带有动效的图片，格式是webm，于是我想能不能把视频也转换成webm这种格式的，查了一下。 WebM是一个由Google资助的项目，目标是构建一个开放的、免著作权费用的视频文件格式。该视频文件格式应能提供高质量的视频压缩以配合HTML5使用。 ——— 维基百科 这不是巧了吗，这不是刚好符合要求，现在唯一的问题就是不知道支不支持透明通道，这还不简单试一下就可以了，一开始采用的是线上转换的方式，这里如果视频比较小推荐使用https://converter.app/mov-to-webm/ 这个平台的（线上转换比较慢，视频太大还有G的风险，后面还有一个方案），其他的诸如格式工厂或者别的在线转换平台不知道是不是我操作又问题，导出的webm都是黑底的。 实验结果webm支持透明通道，并且相对于原视频体积会小很多，并且清晰度没有损耗，效果如下： 到此所有的问题基本上都解决了，还有一个就是mov转webm线上转换太慢的问题，一开始想的是能不能使用现成的软件解决，结果尝试了各种各样的软件都不行，原本透明的视频变成了黑底的，想了好久终于想到了一个贼牛的项目，ffmpeg。github地址：https://github.com/FFmpeg/FFmpeg。 windows的使用比较简单，官网提供的有现成的exe文件，下载下来就可以了，下载地址：https://ffmpeg.org/download.html#build-windows 下载下来之后，配置环境变量方式使用命令行进行调用。 转webm的命令如下，这样就可以保留透明通道。 1234ffmpeg -i input.mov -c:v libvpx-vp9 output.webm// -i input.mov：这是一个选项，表示输入文件。-i 后面跟着要转码的源视频文件的路径// -c:v libvpx-vp9：这也是一个选项，用于指定视频编解码器。-c:v 表示视频编码器，libvpx-vp9 是 VP9 视频编码器的名称。VP9 是一种高效的开源视频编码格式，用于将视频压缩成WebM格式。// output.webm：这是输出文件的名称和格式。在这个例子中，输出文件将以WebM格式保存，并命名为 ` 到此完成，总结ffmpeg是一个非常强大的工具。","categories":[],"tags":[]},{"title":"Electron第一节","slug":"Electron第一节","date":"2023-09-25T16:22:29.000Z","updated":"2023-09-29T15:27:46.883Z","comments":true,"path":"2023/09/25/Electron第一节/","link":"","permalink":"https://yangshijunx.github.io/2023/09/25/Electron%E7%AC%AC%E4%B8%80%E8%8A%82/","excerpt":"","text":"electron第一节Date: September 25, 2023Status: In progressText: 1_Bit 什么是electronBuild cross-platform desktop apps with JavaScript, HTML, and CSS ——— electron官网 简单来说就是，electron就是一个使用js，html和css搭建跨平台桌面应用程序的框架。 每一个electron应用程序的入口都是main文件，这个文件控制了主进程，负责控制应用的整个生命周期，显示原生界面，执行特殊操作并管理渲染进程。 123456789101112131415161718// console.log(&quot;测试demo&quot;)// main.jsconst &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const createWindow = () =&gt; &#123; const win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) win.loadFile(&#x27;index.html&#x27;)&#125;app.whenReady().then(() =&gt; &#123; createWindow()&#125;)// package.json&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;electron .&quot;&#125;, PS:需要注意的是,和vue和react框架一样都需要一个index.html文件。 你可能已经注意到了在main.js 文件中我们从electron中引入了两个模块app,BrowserWindow app 模块，它控制应用程序的事件生命周期。 BrowserWindow 模块，它创建和管理应用程序窗口。 在主进程中可以通过process对象访问node的相关变量，需要注意的是在主线程中是没有办法直接操作dom的因为主线程无法访问渲染器，主线程和渲染线程存在于完全不同的进程。 1234app.whenReady().then(() =&gt; &#123; createWindow() console.log(&quot;测试demo&quot;, window, document)&#125;) 但是我们可以通过预加载脚本访问这两个渲染器，可以同时访问到window和document以及Node.js环境，具体的方法如下。 12345678910111213141516171819202122// preload.jswindow.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; const replaceText = (selector, text) =&gt; &#123; const element = document.getElementById(selector) if (element) element.innerText = text &#125; for (const dependency of [&#x27;chrome&#x27;, &#x27;node&#x27;, &#x27;electron&#x27;]) &#123; replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency]) &#125;&#125;)// 在主线程中使用preload预加载const createWindow = () =&gt; &#123; const win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;), &#125; &#125;) win.loadFile(&#x27;index.html&#x27;)&#125; Electron打包使用Electron Forge进行打包 12npm install --save-dev @electron-forge/clinpx electron-forge import","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://yangshijunx.github.io/tags/Electron/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"2023-09-21T12:11:43.000Z","updated":"2023-09-21T15:57:58.082Z","comments":true,"path":"2023/09/21/原型和原型链/","link":"","permalink":"https://yangshijunx.github.io/2023/09/21/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型和原型链javascript中的对象有一个特殊的Prototype内置属性，其实就是相对于其他对象的引用，几乎所有的对象在创建的时候Prototype属性都有一个非空的值。这个对象就叫做原型对象。 在js中当我们使用对象的某个属性值的时候会触发[[get]] 操作，在进行get操作的时候，第一步检查对象本身是不是有这个属性，如果有就使用，如果没有的话就会检查对象的[[Prototype]] 链。这个过程会检查完整个原型链，如果找不到返回值就是undefined，这个链就叫做原型链。 123456789function People(name, age) &#123; (this.name = name), (this.age = age);&#125;People.prototype.sayHi = function () &#123; console.log(&quot;hello:&quot;, this.name);&#125;;const bob = new People(&quot;bob&quot;, 12);bob.sayHi()VM165:5 hello: bob 在上面的例子中，我们声明了一个构造函数People,并调用该构造函数创建了一个实例bob，在实例bob上面调用sayHi方法，bob上面本身是没有该方法的，那么他就会顺着原型链一层一层查找，直到找到People构造函数的原型对象，并调用。对象通过原型链实现属性和方法的承，每个对象通过内部链接指向其原型对象，形成一个链条。 构造函数我们在上面的例子中创建bob实例的时候使用了new关键字，在面向对象的语言中构造类实例的时候会用到他，所以我们理所当然的认为People是一个“类”。在js中“类”名的首字母一般来说要大写，其实小写也不会有任何问题。我们在使用new关键字创建的对象会有一个constructor 属性，这个属性指向的就是这个构造函数。 那么什么叫构造函数呢，本质上来说构造函数和普通函数没有区别，函数本身并不是构造函数，但是如果你使用new关键字调用这个函数，就会把这个函数调用变成一个“构造函数调用”，实际上，new会劫持所有普通函数并用构造对象的形式来调用他。换句话说对于js中的构造函数就是：所有带new的函数调用。 那么new关键字到底做了什么事情呢？ 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 PS:constructor属性实际上是不被信任的，它们不一定会指向默认的函数引用，可以被修改。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"}]},{"title":"事件循环","slug":"My-New-Post","date":"2023-09-19T14:10:32.000Z","updated":"2023-09-20T13:27:21.379Z","comments":true,"path":"2023/09/19/My-New-Post/","link":"","permalink":"https://yangshijunx.github.io/2023/09/19/My-New-Post/","excerpt":"","text":"EventLoop事件循环现在我们来澄清一件事情（可能令人震惊）：尽管你显然能够编写异步 JavaScript 代码（就像前面我们看到的定时代码），但直到最近（ES6），JavaScript 才真正内建有直接的异步概念 —— 你不知道的javascript 中 因为js是单线程的，单线程就意味着，js代码在执行的任何时候都只有一个主线程来处理所有的任务。为什么js是单线程的呢，一个很重要的原因就是js作为一个脚本语言，他的主要的执行环境就是浏览器，在浏览器中我们需要进行各种各样的dom操作，如果这里js是多线程的就会出现这种情况，比如一条代码需要给某个dom新增事件，另一条代码需要删除这个dom，那到底应该执行那一个就会存在问题。 所以为了防止代码阻塞把任务分为同步任务和异步任务。js在执行任务的时候，把同步代码交给js引擎执行，异步任务交给宿主环境执行。同步代码放入执行栈中，异步代码等待时机成熟送入任务队列排队，执行栈执行完毕之后，会检查任务队列中是否有异步任务，有就推入执行栈执行，以此往复循环，这个过程就叫做事件循环。 执行栈在js中当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（执行上下文），这个执行环境中存在这个方法的私有作用域，上层作用于的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象，因为js是单线程的，所以同一时间只能执行一个方法，于是这些方法就会排队，排队的地方就叫做执行栈。 每当遇到一个同步方法的逐个推入执行栈中，顺序执行。 那么异步方法如何处理的呢？ 任务队列js在遇到一个异步事件之后，并不会等待异步的结果返回，而是将这个事件挂起，继续执行执行栈中的其他任务，当一个异步事件返回结果后，js会将这个事件加入和当前执行站不同的队列中也就是任务队列，放入其中的任务并不会立即执行，二十等待执行栈中的所有任务执行完毕，当执行栈为空的时候，主线程会去检查任务队列是否有剩余任务，如果有的话就推入执行栈中，执行其中的同步代码，这样的往复循环就叫做事件循环。 微任务和宏任务异步任务也不都是相同的，异步任务的执行优先级也不相同，异步任务可以分为两类，分别是微任务和宏任务。 宏任务 setTimeout setInterval setImmediate (Node 独有) requestAnimationFrame (浏览器独有) I&#x2F;O UI rendering (浏览器独有) 微任务 process.nextTick (Node 独有) Promises (准确的说是 Promise.then() 中 then 的回调函数, 而不是 new promise(callback) 携带的回调函数) Object.observeMutationObserverqueueMicrotask Object.observe queueMicrotask 也就是主线程在检查微任务队列是否有事件存在的时候，首先检查微任务队列，如果不存在然后去宏任务队列中取事件加入当前执行栈，如果微任务队列中存在则在同一个事件循环中会将微任务队列中的事件执行完毕之后再执行宏任务队列。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yangshijunx.github.io/tags/React/"},{"name":"Sass","slug":"Sass","permalink":"https://yangshijunx.github.io/tags/Sass/"},{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://yangshijunx.github.io/tags/Electron/"}]}