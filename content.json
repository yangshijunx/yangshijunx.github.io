{"meta":{"title":"1Bit","subtitle":"","description":"不积硅步无以至千里，不积小流无以成江海","author":"1Bit","url":"https://yangshijunx.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-09-19T12:19:09.000Z","updated":"2023-09-19T14:26:48.208Z","comments":true,"path":"categories/index.html","permalink":"https://yangshijunx.github.io/categories/index.html","excerpt":"","text":""},{"title":"repository","date":"2023-09-19T12:21:51.000Z","updated":"2023-09-19T12:21:51.558Z","comments":true,"path":"repository/index.html","permalink":"https://yangshijunx.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-09-19T12:19:56.000Z","updated":"2023-09-19T14:27:04.378Z","comments":true,"path":"tags/index.html","permalink":"https://yangshijunx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Electron第一节","slug":"Electron第一节","date":"2023-09-26T00:22:29.000Z","updated":"2023-09-26T15:20:20.682Z","comments":true,"path":"2023/09/26/Electron第一节/","link":"","permalink":"https://yangshijunx.github.io/2023/09/26/Electron%E7%AC%AC%E4%B8%80%E8%8A%82/","excerpt":"","text":"electron第一节Date: September 25, 2023Status: In progressText: 1_Bit 什么是electronBuild cross-platform desktop apps with JavaScript, HTML, and CSS ——— electron官网 简单来说就是，electron就是一个使用js，html和css搭建跨平台桌面应用程序的框架。 每一个electron应用程序的入口都是main文件，这个文件控制了主进程，负责控制应用的整个生命周期，显示原生界面，执行特殊操作并管理渲染进程。 123456789101112131415161718// console.log(&quot;测试demo&quot;)// main.jsconst &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const createWindow = () =&gt; &#123; const win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) win.loadFile(&#x27;index.html&#x27;)&#125;app.whenReady().then(() =&gt; &#123; createWindow()&#125;)// package.json&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;electron .&quot;&#125;, PS:需要注意的是,和vue和react框架一样都需要一个index.html文件。 你可能已经注意到了在main.js 文件中我们从electron中引入了两个模块app,BrowserWindow app 模块，它控制应用程序的事件生命周期。 BrowserWindow 模块，它创建和管理应用程序窗口。 在主进程中可以通过process对象访问node的相关变量，需要注意的是在主线程中是没有办法直接操作dom的因为主线程无法访问渲染器，主线程和渲染线程存在于完全不同的进程。 1234app.whenReady().then(() =&gt; &#123; createWindow() console.log(&quot;测试demo&quot;, window, document)&#125;) 但是我们可以通过预加载脚本访问这两个渲染器，可以同时访问到window和document以及Node.js环境，具体的方法如下。 1234567891011121314151617181920212223// preload.jswindow.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; const replaceText = (selector, text) =&gt; &#123; const element = document.getElementById(selector) if (element) element.innerText = text &#125; for (const dependency of [&#x27;chrome&#x27;, &#x27;node&#x27;, &#x27;electron&#x27;]) &#123; replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency]) &#125;&#125;)// 在主线程中使用preload预加载const createWindow = () =&gt; &#123; const win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;), &#125; &#125;) win.loadFile(&#x27;index.html&#x27;)&#125; Electron打包使用Electron Forge进行打包 12npm install --save-dev @electron-forge/clinpx electron-forge import","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://yangshijunx.github.io/tags/Electron/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"2023-09-21T12:11:43.000Z","updated":"2023-09-21T15:57:58.082Z","comments":true,"path":"2023/09/21/原型和原型链/","link":"","permalink":"https://yangshijunx.github.io/2023/09/21/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型和原型链javascript中的对象有一个特殊的Prototype内置属性，其实就是相对于其他对象的引用，几乎所有的对象在创建的时候Prototype属性都有一个非空的值。这个对象就叫做原型对象。 在js中当我们使用对象的某个属性值的时候会触发[[get]] 操作，在进行get操作的时候，第一步检查对象本身是不是有这个属性，如果有就使用，如果没有的话就会检查对象的[[Prototype]] 链。这个过程会检查完整个原型链，如果找不到返回值就是undefined，这个链就叫做原型链。 123456789function People(name, age) &#123; (this.name = name), (this.age = age);&#125;People.prototype.sayHi = function () &#123; console.log(&quot;hello:&quot;, this.name);&#125;;const bob = new People(&quot;bob&quot;, 12);bob.sayHi()VM165:5 hello: bob 在上面的例子中，我们声明了一个构造函数People,并调用该构造函数创建了一个实例bob，在实例bob上面调用sayHi方法，bob上面本身是没有该方法的，那么他就会顺着原型链一层一层查找，直到找到People构造函数的原型对象，并调用。对象通过原型链实现属性和方法的承，每个对象通过内部链接指向其原型对象，形成一个链条。 构造函数我们在上面的例子中创建bob实例的时候使用了new关键字，在面向对象的语言中构造类实例的时候会用到他，所以我们理所当然的认为People是一个“类”。在js中“类”名的首字母一般来说要大写，其实小写也不会有任何问题。我们在使用new关键字创建的对象会有一个constructor 属性，这个属性指向的就是这个构造函数。 那么什么叫构造函数呢，本质上来说构造函数和普通函数没有区别，函数本身并不是构造函数，但是如果你使用new关键字调用这个函数，就会把这个函数调用变成一个“构造函数调用”，实际上，new会劫持所有普通函数并用构造对象的形式来调用他。换句话说对于js中的构造函数就是：所有带new的函数调用。 那么new关键字到底做了什么事情呢？ 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 PS:constructor属性实际上是不被信任的，它们不一定会指向默认的函数引用，可以被修改。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"}]},{"title":"事件循环","slug":"My-New-Post","date":"2023-09-19T14:10:32.000Z","updated":"2023-09-20T13:27:21.379Z","comments":true,"path":"2023/09/19/My-New-Post/","link":"","permalink":"https://yangshijunx.github.io/2023/09/19/My-New-Post/","excerpt":"","text":"EventLoop事件循环现在我们来澄清一件事情（可能令人震惊）：尽管你显然能够编写异步 JavaScript 代码（就像前面我们看到的定时代码），但直到最近（ES6），JavaScript 才真正内建有直接的异步概念 —— 你不知道的javascript 中 因为js是单线程的，单线程就意味着，js代码在执行的任何时候都只有一个主线程来处理所有的任务。为什么js是单线程的呢，一个很重要的原因就是js作为一个脚本语言，他的主要的执行环境就是浏览器，在浏览器中我们需要进行各种各样的dom操作，如果这里js是多线程的就会出现这种情况，比如一条代码需要给某个dom新增事件，另一条代码需要删除这个dom，那到底应该执行那一个就会存在问题。 所以为了防止代码阻塞把任务分为同步任务和异步任务。js在执行任务的时候，把同步代码交给js引擎执行，异步任务交给宿主环境执行。同步代码放入执行栈中，异步代码等待时机成熟送入任务队列排队，执行栈执行完毕之后，会检查任务队列中是否有异步任务，有就推入执行栈执行，以此往复循环，这个过程就叫做事件循环。 执行栈在js中当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（执行上下文），这个执行环境中存在这个方法的私有作用域，上层作用于的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象，因为js是单线程的，所以同一时间只能执行一个方法，于是这些方法就会排队，排队的地方就叫做执行栈。 每当遇到一个同步方法的逐个推入执行栈中，顺序执行。 那么异步方法如何处理的呢？ 任务队列js在遇到一个异步事件之后，并不会等待异步的结果返回，而是将这个事件挂起，继续执行执行栈中的其他任务，当一个异步事件返回结果后，js会将这个事件加入和当前执行站不同的队列中也就是任务队列，放入其中的任务并不会立即执行，二十等待执行栈中的所有任务执行完毕，当执行栈为空的时候，主线程会去检查任务队列是否有剩余任务，如果有的话就推入执行栈中，执行其中的同步代码，这样的往复循环就叫做事件循环。 微任务和宏任务异步任务也不都是相同的，异步任务的执行优先级也不相同，异步任务可以分为两类，分别是微任务和宏任务。 宏任务 setTimeout setInterval setImmediate (Node 独有) requestAnimationFrame (浏览器独有) I&#x2F;O UI rendering (浏览器独有) 微任务 process.nextTick (Node 独有) Promises (准确的说是 Promise.then() 中 then 的回调函数, 而不是 new promise(callback) 携带的回调函数) Object.observeMutationObserverqueueMicrotask Object.observe queueMicrotask 也就是主线程在检查微任务队列是否有事件存在的时候，首先检查微任务队列，如果不存在然后去宏任务队列中取事件加入当前执行栈，如果微任务队列中存在则在同一个事件循环中会将微任务队列中的事件执行完毕之后再执行宏任务队列。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://yangshijunx.github.io/tags/Electron/"}]}