{"meta":{"title":"1Bit","subtitle":"","description":"不积硅步无以至千里，不积小流无以成江海","author":"1Bit","url":"https://yangshijunx.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-09-19T12:19:09.000Z","updated":"2023-09-19T14:26:48.208Z","comments":true,"path":"categories/index.html","permalink":"https://yangshijunx.github.io/categories/index.html","excerpt":"","text":""},{"title":"repository","date":"2023-09-19T12:21:51.000Z","updated":"2023-09-19T12:21:51.558Z","comments":true,"path":"repository/index.html","permalink":"https://yangshijunx.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-09-19T12:19:56.000Z","updated":"2023-09-19T14:27:04.378Z","comments":true,"path":"tags/index.html","permalink":"https://yangshijunx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Sass进阶","slug":"Sass进阶","date":"2023-11-06T15:55:14.000Z","updated":"2023-11-06T15:55:50.249Z","comments":true,"path":"2023/11/06/Sass进阶/","link":"","permalink":"https://yangshijunx.github.io/2023/11/06/Sass%E8%BF%9B%E9%98%B6/","excerpt":"","text":"sass进阶（包含css原子化内容）Created: November 6, 2023 10:18 PMClass: sassType: vueReviewed: No SASS在前端开发中sass是必不可少的技能，在开发中对sass最明显的体验就是css嵌套以及变量功能，但是Sass（Syntactically Awesome Stylesheets）作为一种CSS的扩展语言，其内部还有很多增强和有用的功能，以简化和改进CSS代码的编写和维护。Sass具有以下主要特点： 变量sass允许你定义变量来存储颜色，字体，边距等css属性的值，使得在整个样式表中一致地使用这些变量变得容易，可以轻松复用。 嵌套规则：可以嵌套CSS规则，以更清晰地表示HTML元素之间的层次关系。这有助于减少代码的嵌套深度，提高可读性（但是需要避免过深嵌套） 混合器：混合器允许你定义可重用的样式片段，并在多个地方引用它们。这有助于减少代码的重复，使样式更易维护。 继承：Sass支持样式继承，允许一个选择器继承另一个选择器的属性。这有助于创建DRY（Don’t Repeat Yourself）的样式表。 模块化：Sass允许将样式表拆分为多个文件，然后将它们导入到主样式表中，以帮助组织和管理大型项目的样式。 运算：Sass支持在样式中执行算术运算，包括加法、减法、乘法和除法。这使得可以动态计算属性的值。 sass文件已”.scss”或者“.sass”拓展名，生产环境西药编译成css文件，我们在使用webapack进行开发的时候，webpack承担了自动化编译的工作。总的来说，Sass是一种强大的CSS预处理器，它使CSS代码更加模块化、易维护和可读，同时提供了许多便捷的功能来提高前端开发的效率。 ps：这里需要注意一下sass和scss的区别 语法规则: Sass: Sass使用缩进风格的语法，不使用大括号 &#123;&#125; 和分号 **;**。选择器和属性之间使用缩进来表示层次关系。 Scss: Scss使用类似于标准CSS的语法，使用大括号 &#123;&#125; 包围规则块，以及分号 ; 来分隔属性。这使得Scss更接近标准CSS。 文件扩展名: Sass: Sass文件使用 .sass 扩展名。 Scss: Scss文件使用 .scss 扩展名。 易读性: Sass: 由于缩进风格的语法，Sass文件通常更加紧凑，但在视觉上可能不如Scss易读。 Scss: Scss更接近标准CSS，因此它通常更容易阅读和理解，特别是对那些熟悉CSS的开发者来说。 兼容性: Sass: 由于不使用大括号和分号，Sass的语法在某些情况下可能会导致一些语法错误，需要开发者小心处理。 Scss: Scss更接近标准CSS，因此在语法上更容易转换和适应。 sass基础使用sass安装1npm install sass 使用sass将sass类型文件转换为css 1234567.box &#123; .box-content &#123; color: red; &#125;&#125;// 正常来说浏览器是不能直接识别嵌套css的，chrome v112 已经支持嵌套了// 所以我们需要将scss变异成css sass提供四种编译选项 1234nested：嵌套缩进的css代码，它是默认值。expanded：没有缩进的、扩展的css代码。compact：简洁格式的css代码。compressed：压缩后的css代码。 生产环境一般使用compressed，编译命令 1npx sass --style compressed index.scss style.css 编译结果如下： sass使用变量123456$prim-color: green;.box &#123; .box-content &#123; color: $prim-color; &#125;&#125; 同样我们可以将变量嵌套在字符串中，需要写在#{}之中 12345678910$prim-color: green;$side: left;.box &#123; .box-content &#123; color: $prim-color; &#125; .box-side &#123; margin-#&#123;$side&#125;: 30px; &#125;&#125; https://www.notion.so 使用sass计算功能123456789101112$prim-color: green;$marginLeft: 50px;$side: left;.box &#123; .box-content &#123; color: $prim-color; &#125; .box-side &#123; margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; sass继承功能，代码复用1234567891011121314$prim-color: green;$marginLeft: 50px;$side: left;.box &#123; .box-content &#123; color: $prim-color; background-color: red; &#125; .box-side &#123; @extend .box-content; margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; Mixin（可以复用的代码块）1234567891011121314$prim-color: green;$marginLeft: 50px;$side: left;.box &#123; .box-content &#123; color: $prim-color; background-color: red; &#125; .box-side &#123; @extend .box-content; margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; mixin支持传参 123456789101112131415161718192021222324$prim-color: green;$marginLeft: 50px;$side: left;@mixin flex-row &#123; display: flex; flex-direction: row;&#125;@mixin right($right: 40px) &#123; margin-right: $right;&#125;.box &#123; .box-content &#123; @include right(); color: $prim-color; background-color: red; &#125; .box-side &#123; @extend .box-content; @include flex-row; @include right(30px); margin-#&#123;$side&#125;: 30px; margin-left: calc(100vh - $marginLeft); &#125;&#125; sass内置颜色函数1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c darken($color, $amount) 将color颜色加深amount介于0-100%之间 lighten($color, $amount) 将颜色 $color 变亮$mount 是介于 0% 到 100% (含) 之间的值。按照这个值增加 $color HSL 的亮度。 mix($color1, $color2, $weight: 50%) 将颜色 $color1 与 $color2 混合在一起生成新的颜色，$weight 与透明度决定了每个颜色在结果里占的比重。$weight 默认值为 50%。取值范围是介于 0% 到 100% (含) 之间的值。如果指定的比例是 25% ,这意味着第一个颜色所占比例为 25%，第二个颜色所占比例为 75%。 插入文件12@import &quot;index.scss&quot;;@import &quot;index.css&quot;; 循环语句for循环 12345@for $i from 1 through 10 &#123; .margin-left-#&#123;$i&#125; &#123; margin-left: #&#123;$i&#125;px; &#125;&#125; while循环 1234567$index: 1;@while $index &lt; 10 &#123; .margin-right-#&#123;$index&#125; &#123; margin-right: #&#123;$index&#125;px; &#125; $index: $index + 1;&#125; each命令 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(&quot;/image/#&#123;$member&#125;.jpg&quot;); &#125; &#125; 自定义函数123456@function doubleValue($value) &#123; @return $value * 2;&#125;.box-side &#123; border: doubleValue(10px) solid black;&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://yangshijunx.github.io/tags/Sass/"}]},{"title":"","slug":"web端播放透明视频","date":"2023-11-06T14:25:25.591Z","updated":"2023-11-06T14:25:25.591Z","comments":true,"path":"2023/11/06/web端播放透明视频/","link":"","permalink":"https://yangshijunx.github.io/2023/11/06/web%E7%AB%AF%E6%92%AD%E6%94%BE%E9%80%8F%E6%98%8E%E8%A7%86%E9%A2%91/","excerpt":"","text":"web端播放透明视频前两天做了一个官网的项目，产品要求在网页上放一个视频用来介绍这个网站，但是呢要求只保留介绍的人物，不能有多余的环境内容，效果大致是这样的。 产品拿来的效果是一个视频文件，所以没有办法判断参考对象采用的是建模还是直接就在视频上做的效果，仔细想一下直接播放视频不就可以了，想实现这样的效果首先播放器要透明，然后就需要在浏览器中播放带有透明通道的视频就可以了，ok逻辑理清了，就可以开工了。 第一步，播放器透明好像不用哈哈哈哈，播放器就是透明的，不显示播放控件就可以了，那接下来主要的工作就是将介绍视频只保留人像就可以了，产品提供的是绿幕的人像视频使用pr的超级键处理之后，导出格式为mov的保留透明通道的视频就可以了。 第二步，将视频导出只包含人像 在效果里面找到超级键，然后拖拽到视频轨道上面。 点击视频轨道找到效果控件中的超级建选中绿幕，在这个过程中可以选择Alpha通道多次调整，宽容度等参数直到合适。 接着就可以导出视频了，Pr中可以选择QuickTime中具有透明通道的选项。 不出意外，导出的视频是mov格式的，并且相比于原视频会变大很多，我这里两分钟的视频导出的视频3个多G，放到web端这不是开玩笑(别急)。 刚开始，想的是能不能通过压缩视频的形式实现，多番尝试之后失败了，单纯压缩mov视频不能实现，那我可不可以采用别的方式？想了好久，我突然想到之前在做数据可视化项目的时候UI使用AE导出过一个带有动效的图片，格式是webm，于是我想能不能把视频也转换成webm这种格式的，查了一下。 WebM是一个由Google资助的项目，目标是构建一个开放的、免著作权费用的视频文件格式。该视频文件格式应能提供高质量的视频压缩以配合HTML5使用。 ——— 维基百科 这不是巧了吗，这不是刚好符合要求，现在唯一的问题就是不知道支不支持透明通道，这还不简单试一下就可以了，一开始采用的是线上转换的方式，这里如果视频比较小推荐使用https://converter.app/mov-to-webm/ 这个平台的（线上转换比较慢，视频太大还有G的风险，后面还有一个方案），其他的诸如格式工厂或者别的在线转换平台不知道是不是我操作又问题，导出的webm都是黑底的。 实验结果webm支持透明通道，并且相对于原视频体积会小很多，并且清晰度没有损耗，效果如下： 到此所有的问题基本上都解决了，还有一个就是mov转webm线上转换太慢的问题，一开始想的是能不能使用现成的软件解决，结果尝试了各种各样的软件都不行，原本透明的视频变成了黑底的，想了好久终于想到了一个贼牛的项目，ffmpeg。github地址：https://github.com/FFmpeg/FFmpeg。 windows的使用比较简单，官网提供的有现成的exe文件，下载下来就可以了，下载地址：https://ffmpeg.org/download.html#build-windows 下载下来之后，配置环境变量方式使用命令行进行调用。 转webm的命令如下，这样就可以保留透明通道。 1234ffmpeg -i input.mov -c:v libvpx-vp9 output.webm// -i input.mov：这是一个选项，表示输入文件。-i 后面跟着要转码的源视频文件的路径// -c:v libvpx-vp9：这也是一个选项，用于指定视频编解码器。-c:v 表示视频编码器，libvpx-vp9 是 VP9 视频编码器的名称。VP9 是一种高效的开源视频编码格式，用于将视频压缩成WebM格式。// output.webm：这是输出文件的名称和格式。在这个例子中，输出文件将以WebM格式保存，并命名为 ` 到此完成，总结ffmpeg是一个非常强大的工具。","categories":[],"tags":[]},{"title":"Electron第一节","slug":"Electron第一节","date":"2023-09-25T16:22:29.000Z","updated":"2023-09-29T15:27:46.883Z","comments":true,"path":"2023/09/25/Electron第一节/","link":"","permalink":"https://yangshijunx.github.io/2023/09/25/Electron%E7%AC%AC%E4%B8%80%E8%8A%82/","excerpt":"","text":"electron第一节Date: September 25, 2023Status: In progressText: 1_Bit 什么是electronBuild cross-platform desktop apps with JavaScript, HTML, and CSS ——— electron官网 简单来说就是，electron就是一个使用js，html和css搭建跨平台桌面应用程序的框架。 每一个electron应用程序的入口都是main文件，这个文件控制了主进程，负责控制应用的整个生命周期，显示原生界面，执行特殊操作并管理渲染进程。 123456789101112131415161718// console.log(&quot;测试demo&quot;)// main.jsconst &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;)const createWindow = () =&gt; &#123; const win = new BrowserWindow(&#123; width: 800, height: 600 &#125;) win.loadFile(&#x27;index.html&#x27;)&#125;app.whenReady().then(() =&gt; &#123; createWindow()&#125;)// package.json&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;electron .&quot;&#125;, PS:需要注意的是,和vue和react框架一样都需要一个index.html文件。 你可能已经注意到了在main.js 文件中我们从electron中引入了两个模块app,BrowserWindow app 模块，它控制应用程序的事件生命周期。 BrowserWindow 模块，它创建和管理应用程序窗口。 在主进程中可以通过process对象访问node的相关变量，需要注意的是在主线程中是没有办法直接操作dom的因为主线程无法访问渲染器，主线程和渲染线程存在于完全不同的进程。 1234app.whenReady().then(() =&gt; &#123; createWindow() console.log(&quot;测试demo&quot;, window, document)&#125;) 但是我们可以通过预加载脚本访问这两个渲染器，可以同时访问到window和document以及Node.js环境，具体的方法如下。 12345678910111213141516171819202122// preload.jswindow.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; &#123; const replaceText = (selector, text) =&gt; &#123; const element = document.getElementById(selector) if (element) element.innerText = text &#125; for (const dependency of [&#x27;chrome&#x27;, &#x27;node&#x27;, &#x27;electron&#x27;]) &#123; replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency]) &#125;&#125;)// 在主线程中使用preload预加载const createWindow = () =&gt; &#123; const win = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;), &#125; &#125;) win.loadFile(&#x27;index.html&#x27;)&#125; Electron打包使用Electron Forge进行打包 12npm install --save-dev @electron-forge/clinpx electron-forge import","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://yangshijunx.github.io/tags/Electron/"}]},{"title":"原型和原型链","slug":"原型和原型链","date":"2023-09-21T12:11:43.000Z","updated":"2023-09-21T15:57:58.082Z","comments":true,"path":"2023/09/21/原型和原型链/","link":"","permalink":"https://yangshijunx.github.io/2023/09/21/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原型和原型链javascript中的对象有一个特殊的Prototype内置属性，其实就是相对于其他对象的引用，几乎所有的对象在创建的时候Prototype属性都有一个非空的值。这个对象就叫做原型对象。 在js中当我们使用对象的某个属性值的时候会触发[[get]] 操作，在进行get操作的时候，第一步检查对象本身是不是有这个属性，如果有就使用，如果没有的话就会检查对象的[[Prototype]] 链。这个过程会检查完整个原型链，如果找不到返回值就是undefined，这个链就叫做原型链。 123456789function People(name, age) &#123; (this.name = name), (this.age = age);&#125;People.prototype.sayHi = function () &#123; console.log(&quot;hello:&quot;, this.name);&#125;;const bob = new People(&quot;bob&quot;, 12);bob.sayHi()VM165:5 hello: bob 在上面的例子中，我们声明了一个构造函数People,并调用该构造函数创建了一个实例bob，在实例bob上面调用sayHi方法，bob上面本身是没有该方法的，那么他就会顺着原型链一层一层查找，直到找到People构造函数的原型对象，并调用。对象通过原型链实现属性和方法的承，每个对象通过内部链接指向其原型对象，形成一个链条。 构造函数我们在上面的例子中创建bob实例的时候使用了new关键字，在面向对象的语言中构造类实例的时候会用到他，所以我们理所当然的认为People是一个“类”。在js中“类”名的首字母一般来说要大写，其实小写也不会有任何问题。我们在使用new关键字创建的对象会有一个constructor 属性，这个属性指向的就是这个构造函数。 那么什么叫构造函数呢，本质上来说构造函数和普通函数没有区别，函数本身并不是构造函数，但是如果你使用new关键字调用这个函数，就会把这个函数调用变成一个“构造函数调用”，实际上，new会劫持所有普通函数并用构造对象的形式来调用他。换句话说对于js中的构造函数就是：所有带new的函数调用。 那么new关键字到底做了什么事情呢？ 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 PS:constructor属性实际上是不被信任的，它们不一定会指向默认的函数引用，可以被修改。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"}]},{"title":"事件循环","slug":"My-New-Post","date":"2023-09-19T14:10:32.000Z","updated":"2023-09-20T13:27:21.379Z","comments":true,"path":"2023/09/19/My-New-Post/","link":"","permalink":"https://yangshijunx.github.io/2023/09/19/My-New-Post/","excerpt":"","text":"EventLoop事件循环现在我们来澄清一件事情（可能令人震惊）：尽管你显然能够编写异步 JavaScript 代码（就像前面我们看到的定时代码），但直到最近（ES6），JavaScript 才真正内建有直接的异步概念 —— 你不知道的javascript 中 因为js是单线程的，单线程就意味着，js代码在执行的任何时候都只有一个主线程来处理所有的任务。为什么js是单线程的呢，一个很重要的原因就是js作为一个脚本语言，他的主要的执行环境就是浏览器，在浏览器中我们需要进行各种各样的dom操作，如果这里js是多线程的就会出现这种情况，比如一条代码需要给某个dom新增事件，另一条代码需要删除这个dom，那到底应该执行那一个就会存在问题。 所以为了防止代码阻塞把任务分为同步任务和异步任务。js在执行任务的时候，把同步代码交给js引擎执行，异步任务交给宿主环境执行。同步代码放入执行栈中，异步代码等待时机成熟送入任务队列排队，执行栈执行完毕之后，会检查任务队列中是否有异步任务，有就推入执行栈执行，以此往复循环，这个过程就叫做事件循环。 执行栈在js中当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（执行上下文），这个执行环境中存在这个方法的私有作用域，上层作用于的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象，因为js是单线程的，所以同一时间只能执行一个方法，于是这些方法就会排队，排队的地方就叫做执行栈。 每当遇到一个同步方法的逐个推入执行栈中，顺序执行。 那么异步方法如何处理的呢？ 任务队列js在遇到一个异步事件之后，并不会等待异步的结果返回，而是将这个事件挂起，继续执行执行栈中的其他任务，当一个异步事件返回结果后，js会将这个事件加入和当前执行站不同的队列中也就是任务队列，放入其中的任务并不会立即执行，二十等待执行栈中的所有任务执行完毕，当执行栈为空的时候，主线程会去检查任务队列是否有剩余任务，如果有的话就推入执行栈中，执行其中的同步代码，这样的往复循环就叫做事件循环。 微任务和宏任务异步任务也不都是相同的，异步任务的执行优先级也不相同，异步任务可以分为两类，分别是微任务和宏任务。 宏任务 setTimeout setInterval setImmediate (Node 独有) requestAnimationFrame (浏览器独有) I&#x2F;O UI rendering (浏览器独有) 微任务 process.nextTick (Node 独有) Promises (准确的说是 Promise.then() 中 then 的回调函数, 而不是 new promise(callback) 携带的回调函数) Object.observeMutationObserverqueueMicrotask Object.observe queueMicrotask 也就是主线程在检查微任务队列是否有事件存在的时候，首先检查微任务队列，如果不存在然后去宏任务队列中取事件加入当前执行栈，如果微任务队列中存在则在同一个事件循环中会将微任务队列中的事件执行完毕之后再执行宏任务队列。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://yangshijunx.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://yangshijunx.github.io/tags/Sass/"},{"name":"Javascript","slug":"Javascript","permalink":"https://yangshijunx.github.io/tags/Javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://yangshijunx.github.io/tags/Electron/"}]}